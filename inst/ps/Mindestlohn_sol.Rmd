## Mindestlöhne und Unternehmensgewinne - Eine interaktive Analyse mit R


#< ignore
```{r "setup"}
library(RTutor)
# Adapt working directory
setwd("C:/Users/lasse/Documents/GitHub/RTutorMindestlohn/inst/Mindestlohn")
ps.name = "Mindestlohn"; sol.file = paste0(ps.name,"_sol.Rmd")
# character vector of all packages you load in the problem set
libs = c("ggplot2","haven","stargazer","sandwich", "ggdag", "lfe", "broom") 
create.ps(sol.file=sol.file, ps.name=ps.name,libs=libs, rps.has.sol=TRUE, addons="quiz")
# Show the problem set in the webbrowser
show.ps(ps.name,sample.solution=FALSE,auto.save.code = TRUE)
```
#>

## Exercise Inhaltsübersicht

Herzlich Willkommen zu diesem interaktiven RTutor Problem Set.
Im Rahmen meiner Bachelorarbeit gehen wir den Zusammenhängen von Mindestlöhnen und der Unternehmensprofitabilität auf den Grund.
Die Basis bildet der Artikel [Minimum Wages and Firm Profitability](https://www.aeaweb.org/articles?id=10.1257/app.3.1.129) von Mirko Draca, Stephen Machin und John Van Reenen, erschienen im Januar 2011 im American Economic Journal: Applied Economics. 

Kommen Sie mit auf eine Reise ins Vereinigte Königreich und seine Arbeitswelt. 

Durch die Verknüpfung von inhaltlichen Hintergründen, fachlicher Analyse von Ergebnissen, persönlichen Einschätzungen und technischer Arbeit mit der Statistiksoftware R sollen Sie durch dieses Problem Set von einem fundierten Wissenszuwachs profitieren. \
Es ist das Ziel, dass Sie sich nach der geführten Erarbeitung des Themas kritisch und differenziert mit politischen Mindestlohnforderungen auseinandersetzen können und dazu in der Lage sind, Ihre Meinungsbildung ökonomisch zu begründen. \
Zudem wird Ihnen die Möglichkeit geboten, sich kritisch mit Fachliteratur auseinanderzusetzen und Analysen einzuordnen.


### Inhalt

1. Einführung in den Mindestlohn

2. Datenüberblick

3. Difference in Differences

    3.1 Wahl der Gruppen

    3.2 Händische DiD Berechnung

    3.3 DiD-Schätzung mittels Regression
    
    3.4 Weiterführende Analysen

4. Einordnung des Artikels



## Exercise 1 Einführung in den Mindestlohn

**"Jetzt 12€ Mindestlohn wählen."**

Ein zentrales Wahlkampfthema der SPD zur Bundestagswahl 2021. Es war nicht das erste Mal und wird auch nicht das letzte Mal gewesen sein, dass die Versprechung zur Verbesserung des Lohns ein zentrales Instrument der Arbeitsmarktpolitik ist, um eine große Wählerschaft zu mobilisieren. \
Hinter diesem leicht verständlichen Versprechen steckt allerdings die komplexe Frage, wie die Lohnerhöhungen getragen werden.

Häufig wird in der Forschung die Frage der Auswirkungen auf die Beschäftigung betrachtet. Dabei treten Kontroversen auf und es herrscht keine Einigkeit in den Schlussfolgerungen. \
Daher wählen wir mit unserer Analyse nach Draca et. al (2011) einen anderen Ansatz. \
Anstatt die Beschäftigung in den Vordergrund zu rücken, widmen wir uns der vorgelagerteten Frage, wie die Lohnsteigerungen innerhalb von Unternehmen kompensiert werden. \
Eine solche Betrachtungsweise ist nach den Autoren in der Forschung bisher weitestgehend unbeachtet geblieben (vgl. Draca et. al (2011), S. 129f.)


Die Basis der Analyse bilden Unternehmensdaten aus dem Vereinigten Königreich (UK).

#< quiz "1"
question: Wie können Unternehmen die Lohnsteigerung kompensieren?
sc:
    - Verkleinerung der Gewinnmarge*
    - Weitergabe der Kostensteigerung an Verbraucher
    - Effizienzsteigerung

success: Auf dieser Vermutung beruht unsere Untersuchung.
failure: Eine plausible Antwort, allerdings werden hierfür keine Belege gefunden (vgl. Draca et al. (2011), S.130)
#>

<br>

**Hintergrund der Einführung**

Wie in Deutschland, wurden und werden Löhne im Vereinigten Königreich teilweise durch Tarifverhandlungen festgelegt. \
Die Notwendigkeit der Einführung eines nationalen Mindestlohns wurde in Großbritannien durch den sinkenden Einfluss von Gewerkschaften gesehen. \
Haben im Jahr 1970 noch 80% der Arbeitnehmer von Tarifverträgen profitiert, so sank dieser Anteil bis 2000 um 50 Prozentpunkte.
Mit einem Machtwechsel im britischen Unterhaus, hin zur sozialdemokratischen Labour-Partei, kommt es zur Veränderung in der Arbeitsmarktpolitik. Zum 1. April 1999 wird der nationale Mindestlohn eingeführt. \

*(vgl. Brown (2007), S.2f.)*

#< quiz "1.1"
question: Auf welche Höhe schätzen Sie den gesetzlichen Mindestlohn im Vereinigten Königreich zur Einführung 1999?
sc:
    - 3.60£*
    - 5.70£ 
    - 7.80£

success: Korrekt. Der Artikel befasst sich mit der Einführung des Mindestlohns in Höhe von 3.60 Pfund.
failure: Diese Schätzung ist zu hoch.
#>

*Hinweis*: Wir verwenden einheitlich den Punkt als Dezimaltrennzeichen, da sich unsere Daten und die Software ebenfalls auf diese Konvention stützen.


Weiter gilt zu erwähnen, dass der nationale Mindestlohn (NMW) nicht die erste Art des Mindestlohns im Vereinigten Königreich war. \
Von 1909 bis zum Jahr 1993 an wurden gesetzliche Mindestlöhne durch *Wage Councils* innerhalb von Branchen bestimmt. \
Das Novum des NMW liegt in der Reichweite über alle Branchen hinweg. Ähnlich wie die *Wage Councils*, gibt die unabhängige Niedriglohnkommission (LPC) eine Empfehlung zur Mindestlohnhöhe. \
Von 1999 an wird die Lohnhöhe fortlaufend von der Niedriglohnkomission angepasst.

#< quiz "1.2"
question: Auf welche Höhe schätzen Sie den gesetzlichen Mindestlohn im UK im Jahr 2024?
sc:
    - 9.11£
    - 11.22£*
    - 14.44£
    

success: Korrekt. Für Personen über 21 gilt dieser Mindestlohn seit April 2024 an.
failure: Diese Schätzung ist falsch.
#>

#< info "Aufgliederung des Mindestlohns"
Der volle Mindestlohn im Vereinigten Königreich wird erst ab dem Alter von 21 Jahren gezahlt. Die genaue Aufgliederung, sowie die künftig geplanten Anpassungen können sie sich [auf der Internetseite der Regierung](https://www.gov.uk/national-minimum-wage-rates) ansehen.
#>


### Theorie der Unternehmensgewinne

Den theoretischen Ausgangspunkt für die Analyse bietet die Idee der Profitmaximierung nach Ashenfelter & Smith (1979). \
Dabei wird von einem gewinnmaximierenden Unternehmen ausgegangen, dessen Gewinn $Π(W,R,P)$ anhand von Variablen des Lohnsatzes $W$, der Kosten $R$ und des Outputpreises $P$ gemessen wird.

Aus der abgeleiteten Funktion der Gewinnmaximierung erhalten wir die negative Arbeitsnachfrage $-L(W,R,P)$.

In unserem Fall wird der Lohnsatz auf die Höhe des Mindestlohns M angepasst. Dadurch entsteht zum Zeitpunkt der Mindestlohneinführung eine Gewinnveränderung von
$$ΔΠ = Π(W,R,P) - Π(M,R,P)$$

Unter Gebrauch einer Taylor-Reihe, kann die Gewinnveränderung approximiert dargestellt werden:

$$ΔΠ ≅ − LΔW + \frac{1}{2} \frac{\partial L}{\partial W}(ΔW)^2$$

Zusätzlich führen wir die Variable *S* ein, die den Umsatz eines Unternehmens definiert. Dadurch können wir die Gewinnmarge $\frac{Π}{S}$ darstellen und erhalten 
$$Δ(\frac{Π}{S}) = − θ(\frac{ΔW}{W})$$
wobei $θ = \frac{ΔWL}{S}$

Gehen wir nun wie oben bereits erläutert von einer Lohnveränderung 
$ΔW = W - M$ aus.

Im Falle eines negativen $ΔW$ können wir auf Basis dieser Gleichung von einer Verringerung der Gewinnmarge ausgehen. \
Diese Grundlage wird später für unsere Difference-in-Difference Analyse und der einhergehenden Wahl der Gruppen relevant. \
*(vgl. Draca et al. (2011), S.131f.)*


## Exercise 2 Datenüberblick


#< quiz "2.1"
question: Um in den Datensatz einzutauchen eine kleine Frage zum Einstieg. Was glauben Sie, wieso wir Unternehmensdaten aus dem Vereinigten Königreich beziehen?
sc:
    - Keine Kosten der Datenbeschaffung im Vereinigten Königreich
    - Strengere Transparenzregeln in der Bilanzierung und eine zentrale Datenspeicherung*
    - Die Daten sind anonymisiert und lassen eine unternehmensunabhängige Analyse zu

success: Das ist ein wichtiger Grund, warum wir uns mit Daten aus dem UK beschäftigen. Dabei werden die Daten in unserem Fall kommerziell vom "Bureau Van Dijk" bezogen. Eine unternehmensunabhängige Analyse wäre mit Hinblick auf branchenspezifische Einflüsse nicht zielführend.
failure: Die Antwort ist leider falsch.
#>


**Aufgabe**: Lesen Sie den Datensatz `main_fame.dta` mit der Funktion `read_dta` ein und speichern Sie den Datensatz unter `dat`. Führen Sie den Code aus, indem Sie ``check`` drücken.
```{r}
#< task

#>
dat = read_dta('main_fame.dta')
```

**Aufgabe:** Um einen ersten Überblick über den Datensatz zu bekommen, geben sie die ersten Zeilen des Datensatzes `dat` mittels der Funktion `head` aus.
```{r}
#< task

#>
head(dat)
```

Wir erhalten eine Vielzahl an Variablen, die mehr oder minder relevant für unsere Analysen sind. \
Widmen wir uns den wesentlichsten Variablen für unsere Analyse:

**regno**: Hier handelt es sich um eine bestimmte Nummer, mit der die Daten jedem bestimmten Unternehmen zugeordnet werden können.

**year**: Gibt das Jahr an, aus dem die Daten stammen. Dabei wird das zurückliegende Geschäftsjahr betrachtet.

**ln_avwage**: Benennt den logarithmierten Durchschnittslohn im Unternehmen.

**net_pcm**: Die Gewinnmarge eines Unternehmens wir durch die Division vom Nettogewinn durch den Gesamtumsatz im Geschäftsjahr angegeben.

**sic2**: Die Unternehmen werden in Großbritannien nach Branchen in unterschiedliche Branchen unterteilt. Der bis zu vierstellige UKsic (UK Standard Industrial Classification of Economic Activities) beschreibt dabei die Branchen. \
Das oben ausgegebene Unternehmen besitzt den UKsic 7020. Die sic2-Zahl ist somit 70 und beschreibt Immobilienaktivitäten.   
Eine Übersicht über alle Branchen ist [hier](https://webarchive.nationalarchives.gov.uk/ukgwa/20160105160709/http://www.ons.gov.uk/ons/guide-method/classifications/archived-standard-classifications/uk-standard-industrial-classification-1992--sic92-/uk-sic-2003.pdf) zu finden.

**unionmem**: Beschreibt den Anteil an Gewerkschaftsmitgliedern innerhalb des Unternehmens.

**ptwk**: Anteil an Teilzeitarbeitern innerhalb der vierstelligen UKsic-Branche (sic4).

**female**: Frauenanteil bei Arbeitnehmern innerhalb des sic4.

**gorwk**: Gibt den Regierungsbezirk des jeweiligen Unternehmens an. 
Dabei handelt es sich um Bezirke in England (1-17), Wales(18) und Schottland(19,20).

Werfen wir einen Blick auf die Variable *month*. Wir wollen sehen, wann die Unternehmen ihren Jahresbericht abgeben und damit ihr Geschäftsjahr beenden.

**Aufgabe:** Gruppieren Sie hierfür den Datensatz `dat` nach dem Berichtsmonat `month`. Geben Sie anschließend die Anzahl der Einträge mittels der Funktion `length()` an.
```{r}
#< fill_in
dat %>% 
  group_by(___) %>%
  summarize("Einträge" = ___(month))
#>
dat %>% 
  group_by(month) %>%
  summarize(length(month))
```

#< quiz "2.2"
question: Alle unsere Daten weisen auf ein Ende des Geschäftsjahres im März hin. Können Sie sich erklären, warum?
sc:
    - Anders als in Deutschland, endet das Geschäftsjahr im UK bei allen Unternehmen im März.
    - Im Frühjahr gibt es im UK wenig Bewegung auf dem Arbeitsmarkt. Dadurch vermeiden wir unbekannte externe Effekte.
    - Die Mindestlohneinführung findet bei diesen Unternehmen nicht mitten im Geschäftsjahr statt.*

success: Richtige Antwort. Dadurch können wir zwei klare Perioden vor und nach der Mindestlohneinführung definieren.
failure: Die Antwort ist leider falsch.
#>


## Exercise 3 DiD -- Difference in Differences

Die Auswirkungen des Mindestlohns auf die Unternehmensgewinne können mit Hilfe der Difference-in-Differences-Methode - kurz **DiD** - beobachtet werden.


Die DiD-Schätzung ist häufig geeignet, um kausale Effekte politischer Maßnahmen empirisch zu beurteilen. \
Dabei werden die Daten in zwei zeitliche Perioden und zwei Gruppen eingeteilt. \
*(vgl. Callaway et al. (2021), S. 2)*

Gerade mit Hinblick auf Lohnentwicklungen stellte die Methode bereits in der Vergangenheit eine wichtige Grundlage. \
So können beispielsweise die Einflüsse von Schocks und fixer Effekte abgefedert werden und so die Auswirkungen einzelner Maßnahmen besser beurteilbar machen. \
*(vgl. Angrist et al. (2009), S. 169)*




## Exercise 3.1 Wahl der Gruppen

Bei der Difference in Differences Methode werden die Daten anhand von zwei Kriterien unterteilt. \
Zum einen wird entschieden, ob es sich um eine Pre-Treatment oder eine Post-Treatment Gruppe handelt.

#< info "zeitliche Treatmentgruppen"
Bei der DiD-Schätzung ist ein genauer Zeitpunkt ermittelbar, zu dem es ein Treatment gibt. \
In unserem Fall ist dieses Treatment die Einführung des nationalen Mindestlohns. \
Alle Daten, die aus einer Zeit vor dem Treatment stammen, sind Teil der Pre-Treatment Gruppe. \
Jene Daten, die seit dem Treatment erfasst wurden, werden der Post-Treatment Gruppe zugeordnet. \
*(vgl. Angrist et al. (2009), S. 169ff.)*
#>

Zur Erinnerung: Der gesetzliche Mindestlohn wurde am 01. April 1999 eingeführt.

#< quiz "3.1.1"
question: Ab welchem Zeitpunkt werden Daten der Post-Treatment Gruppe zugewiesen? 
sc:
    - 1999
    - 2000*

success: Richtige Antwort. Die Einführung war zwar im Jahr 1999, die Daten jeden Jahres beziehen sich allerdings auf das vergangene Geschäftsjahr (April bis März).
failure: Das ist nicht korrekt. 
#>

Für eine DiD-Schätzung muss weiter eine Kontroll- und eine Treatmentgruppe definiert werden. \
In der Treatmentgruppe sollen jene Unternehmen zusammengefasst werden, bei denen der Durchschnittslohn (avwage) im Jahr unter 12000 Pfund lag. \
Die Kontrollgruppe umfasst Unternehmensdaten mit einem Durchschnittslohn zwischen 12000 und 20000 Pfund. \
Eine genauere Bewertung zur Wahl dieser Gruppen erfolgt zu einem späteren Zeitpunkt.



### Parallele Trends
Als relevante Voraussetzung für das Anwenden der DiD-Methode wird die Parallel-Trends-Assumption (PTA) gehandelt. \
Diese besagt, dass ohne die Einführung eines Treatments, die Linien der Kontroll- und Treatmentgruppe weitestgehend parallel weiterliefen. \
Annähernd kann das überprüft werden, indem man sich die Trendlinien der beiden Gruppen vor Einführung des Treatments ansieht. \
*(vgl. Angrist et al. (2009), S. 171f.)*

**Aufgabe**: Lesen Sie hierfür zunächst den Datensatz `main_fame` ein und speichern ihn unter `dat`.
```{r}
#< fill_in
___ = read_dta('main_fame.dta')
#>
dat = read_dta('main_fame.dta')
```

Um die Daten jeden Jahres zusammenzufassen, kann die Funktion `group_by` genutzt werden. 

#< info "group_by"
Die group_by Funktion aus dem dplyr Paket fasst die Daten anhand einer zu bestimmenden Variablen zusammen und ordnet die Ergebnisse aufsteigend an. \
Um die Gruppierung in einem Output sichtbar zu machen, kann die Pipe um den `summarise` Befehl erweitert werden, in dem dann die Werte jeder Einheit zusammengefasst werden können. \
(https://dplyr.tidyverse.org/reference/group_by.html)
#>

**Aufgabe**: Fügen Sie die passende Variable in `group_by` ein und geben Sie für jedes Jahr den durchschnittlichen logarithmierten Durchschnittslohn aus.
```{r}
#< fill_in
dat_trend_treat = dat %>% 
  filter(ctreat1 == 1) %>%
  group_by(___)%>%
  summarise("treatment"=___(ln_avwage, na.rm = TRUE)) 
#>
dat_trend_treat = dat %>% 
  filter(ctreat1 == 1) %>%
  group_by(year)%>%
  summarise("treatment"=mean(ln_avwage, na.rm = TRUE)) 
```


Analog dazu erstellen wir auch noch einen Datensatz der Kontrollgruppe. 

**Aufgabe**: Führen Sie dazu den Code mittels *check* aus.
```{r}
#< task
dat_trend_control = dat %>%
  filter(ctreat1 == 0) %>%
  group_by(year) %>%
  summarise("control"=mean(ln_avwage, na.rm = TRUE))
#>

```

Um die beiden erstellten Datensätze miteinander zu verbinden, nutzen wir den `left_join`.

**Aufgabe**: Führen Sie den Code mittels *check* aus und sehen sich den Datensatz an.
```{r}
#< task
dat_trend = left_join(dat_trend_treat, dat_trend_control)

dat_trend
#>
```


Jetzt können wir die Daten **visualisieren**, indem wir uns in einem Liniendiagramm die Trends beider Gruppen ausgeben lassen.

Die Basis dafür bildet der oben erstellte Datensatz `dat_trend`.

**Aufgabe**: Fügen Sie die Trendlinien der beiden Gruppen hinzu, indem Sie den Code um die fehlende Variable auf der Y-Achse ergänzen.  
```{r}
#< fill_in
ggplot(dat_trend)+
  geom_line(aes(x = year, y = treatment))+
  geom_line(aes(x = year, y = ___))
#>
ggplot(dat_trend)+
  geom_line(aes(x = year, y = treatment))+
  geom_line(aes(x = year, y = control))
```

Wir können schon etwas ablesen, die Graphik kann allerdings noch ansehnlicher gestaltet werden um Unterschiede deutlicher zu machen.\
Dafür können wir die Linien kolorieren und sowohl die Lininenstärke, als auch den Linientyp verändern.

**Aufgabe**: Färben Sie die Linie der Treatmentgruppe in blau und die der Kontrollgruppe in rot. \
*Hinweis*: Der englische Farbenname muss in Anführungszeichen angegeben werden.
```{r}
#< fill_in
ggplot(dat_trend)+
   geom_line(aes(x = year, y = treatment), colour= ___, linetype = 1, linewidth = 0.8)+
   geom_line(aes(x = year, y = control), colour = ___, linetype = 1, linewidth = 0.8)
#>
ggplot(dat_trend)+
   geom_line(aes(x = year, y = treatment), colour= "blue", linetype = 1, linewidth = 0.8)+
   geom_line(aes(x = year, y = control), colour = "red", linetype = 1, linewidth = 0.8)
```

Um klarzumachen, in welcher Periode wir uns befinden, kann der Zeitpunkt der Einführung des nationalen Mindestlohns markiert werden.

**Aufgabe**: Fügen Sie hierfür das letzte Jahr ein, in dem der Mindestlohn nicht galt. \
*Erinnerung:* Das Jahr gibt das Ende des letzten Geschäftsjahres an.
```{r}
#< fill_in
ggplot(dat_trend)+
   geom_line(aes(x = year, y = treatment), colour= "blue", linetype = 1, linewidth = 0.8)+
   geom_line(aes(x = year, y = control), colour = "red", linetype = 1, linewidth = 0.8)+
   geom_vline(xintercept = ___)
#>
ggplot(dat_trend)+
   geom_line(aes(x = year, y = treatment), colour= "blue", linetype = 1, linewidth = 0.8)+
   geom_line(aes(x = year, y = control), colour = "red", linetype = 1, linewidth = 0.8)+
   geom_vline(xintercept = 1999)
  
```

Zum Abschluss geben wir dem Graphen einen Titel, sowie eine passende Achsenbeschriftung.

**Aufgabe**: Führen Sie den Code mittels *check* aus.
```{r}
#< task
ggplot(dat_trend)+
   geom_line(aes(x = year, y = treatment), colour= "blue", linetype = 1, linewidth = 0.8)+
   geom_line(aes(x = year, y = control), colour = "red", linetype = 1, linewidth = 0.8)+
   geom_vline(xintercept = 1999)+
  xlab("Jahr")+
  ylab("logarithmierter Durchschnittslohn")+
  ggtitle("Entwicklung von ln_avwage")
#>
```

#< award "Prince(ss) of Arts"
Sie haben erfolgreich ein Liniendiagramm mit *ggplot2* entwickelt und bewiesen, dass Sie mit Graphiken umgehen können
#>


#< quiz "3.1.2"
question: Erkennen Sie in der Graphik einen parallelen Trend?
sc:
    - Ja
    - Nein*

success: Während die Löhne in der Kontrollgruppe konstant zu steigen scheinen, läuft der Trend der Treatmentgruppe nicht konstant und auf einem gleichbleibenden Niveau.
failure: Auch wenn es hier meist um eine subjektive Einschätzung geht, sollten Sie sich die unterschiedlichen Steigungen der Trends ansehen.
#>

In unserer Betrachtungsweise ist kein eindeutig paralleler Trend zu erkennen. Ist deshalb die DiD-Schätzung eine falsche Methode, um die Effekte der Mindestlohneinführung zu betrachten? 

Aufgrund des kurzen Betrachtungszeitraums des Trends sollte diese Einschätzung auch mit Vorsicht genossen werden: Es wird sich auf Trends bezogen, die sich auf sechs Datenpunkte (1994-1999) stützen. \
Die Betrachtung eines größeren Zeitraums könnte hier eine genauere Betrachtung zulassen. \
Bezüglich der PTA gibt es seitens der Autoren keine weiterführenden Analysen, eine Erwähnung wird innerhalb des Artikels vergeblich gesucht.

### Treatmentwahl

Nachdem wir um die Komplexität der allgemeinen Voraussetzungen für eine DiD-Schätzung wissen, können wir uns weiter der Relevanz der Gruppenwahl widmen. \
In der erstellten Graphik haben wir die Treatment- und Kontrollgruppen zunächst als gegeben angenommen, ohne die Entstehung zu hinterfragen. \
Der Frage der Entstehung gehen wir nun nach.


Als Einstieg sehen wir uns dafür die Veränderung der Löhne über die Jahre an. \
Um die Veränderung der Löhne von Geschäftsjahr zu Geschäftsjahr herauszufinden, muss der Datensatz nach Jahren aufgeteilt werden. \
Das gelingt, indem für jedes Jahr ein eigener Datensatz erstellt wird. Dafür muss der bereits eingelesene Datensatz dat_main zunächst gefiltert werden.

**Aufgabe**: Wählen Sie die passende Variable für das leere Feld und überprüfen Sie Ihre Eingabe durch *check*.
```{r}
#< fill_in
pcw95 = dat %>%
  filter(___ == 1995) %>%
  filter(avwage >= 3)
#>
#
pcw95 = dat %>%
  filter(year == 1995)%>%
  filter(avwage >= 3)
```


Nun befinden sich in `pcw95` alle Daten aus `dat_main`, die aus dem Jahr 1995 stammen. \
Neben der Unterscheidung in den Jahren sollen zudem die Unterschiede der Ausgangslöhne herausgestellt werden. \
Dazu werden die Löhne in Perzentile aufgeteilt.

**Aufgabe**: Erstellen Sie einen Vektor `percent95`, der die logarithmierten Durchschnittslöhne in 100 Perzentile aufteilt. Nutzen Sie dafür die Funktion `quantile(dat,seq())`. Setzen Sie den fehlenden Wert in `seq()` ein, um einen Vektor der Länge 100 zu erhalten.
```{r}
#< fill_in
percent95 = quantile(pcw95$ln_avwage, seq(0, 1, ___))
#>
percent95 = quantile(pcw95$ln_avwage, seq(0, 1, 0.01))
```

Diese Aufteilung muss nun für jedes Jahr des Datensatzes wiederholt werden.

**Aufgabe**: Führen sie dafür den Chunk durch *check* aus.
```{r}
#< task

pcw96 = dat %>%
  filter(year == 1996)%>%
  filter(avwage >= 3)
percent96 = quantile(pcw96$ln_avwage, seq(0, 1, 0.01))

pcw97 = dat %>%
  filter(year == 1997)%>%
  filter(avwage >= 3)
percent97 = quantile(pcw97$ln_avwage, seq(0, 1, 0.01))

pcw98 = dat %>%
  filter(year == 1998)%>%
  filter(avwage >= 3)
percent98 = quantile(pcw98$ln_avwage, seq(0, 1, 0.01))

pcw99 = dat %>%
  filter(year == 1999)%>%
  filter(avwage >= 3)
percent99 = quantile(pcw99$ln_avwage, seq(0, 1, 0.01))

pcw00 = dat %>%
  filter(year == 2000)%>%
  filter(avwage >= 3)
percent00 = quantile(pcw00$ln_avwage, seq(0, 1, 0.01))

pcw01 = dat %>%
  filter(year == 2001)%>%
  filter(avwage >= 3)
percent01 = quantile(pcw01$ln_avwage, seq(0, 1, 0.01))

pcw02 = dat %>%
  filter(year == 2002)%>%
  filter(avwage >= 3)
percent02 = quantile(pcw02$ln_avwage, seq(0, 1, 0.01))

#>

```


Nun können die Unterschiede in jedem einzelnen Perzentil von Jahr zu Jahr ermittelt werden. Die Differenzen sollen in einem Datensatz gespeichert werden. \
Dafür wird zunächst ein Datensatz erstellt, der sich nach den Werten der Perzentile aus dem ersten Beobachtungsjahr 1995 richtet.

**Aufgabe**: Erstellen Sie einen Datensatz `diffperc` mittels der Funktion `data.frame`. Dieser soll zunächst die Werte aus `percent95` enthalten, welche durch `sort()` geordnet sind.
```{r}
#< task

#>
diffperc = data.frame(sort(percent95))
```


Der Datensatz diffperc kann jetzt um die Differenzen innerhalb der Perzentile erweitert werden.

**Aufgabe**: Führen Sie den Code mit *check* aus.
```{r}
#< task
diffperc = diffperc %>%
  mutate("percentile" = c(0:100),
         "diff96" = percent96-percent95,
         "diff97" = percent97-percent96,
         "diff98" = percent98-percent97,
         "diff99" = percent99-percent98,
         "diff00" = percent00-percent99,
         "diff01" = percent01-percent00,
         "diff02" = percent02-percent01)

#>
```


Für die Betrachtungsweise der Auswirkungen durch die Einführung des Mindestlohns sind zwei Differenzen von besonderer Bedeutung. \
Daher sollen die Änderung des Lohns im Jahr **vor** der Einführung (`diff99`) mit der Änderung im Jahr **nach** der Einführung (`diff00`) in einem Liniendiagramm gegenübergestellt werden.

```{r}
#< task

diffperc = filter(diffperc, percentile < 76 & percentile > 0)
ggplot(diffperc)+
  geom_line(aes(x = percentile, y = diff99), colour = "blue", linetype = 2, linewidth = 0.8)+
  geom_line(aes(x = percentile, y = diff00), colour = "red", linewidth = 0.8)+
  geom_vline(xintercept = 13)+
  geom_vline(xintercept = 50)+
  xlab("Perzentile der Ausgangsdurchschnittslöhne")+
  ylab("Änderung des logarithmierten Durchschnittslohns")
#>
```

Es wird deutlich, dass vorallem in den unteren 13 Perzentilen von der Mindestlohneinführung profitiert wird und die Unterschiede in der Lohnerhöhung am Größten sind.

Die graphische Veranschaulichung möchten wir auch technisch nachvollziehen. \
Erinnern wir uns hierfür zunächst an den theoretischen Zusammenhang von Gewinnmargen und Lohnerhöhungen:

#< quiz "3.1.3"
question: Wann kann ein negativer Einfluss auf die Gewinnmarge $Δ(\frac{Π}{S})$ entstehen?
sc:
    - Wenn der Mindestlohn höher als der bisherige Lohn ist, also $ΔW = W - M < 0$*
    - Wenn der Mindestlohn niedrier als der bisherige Lohn ist, also $ΔW = W - M > 0$

success: Richtige Antwort. 
failure: Für diesen Fall würde das gewählte Modell nicht zutreffen.
#>

Im Mittelpunkt der Mindestlohneinführung steht der Wert von 3.60 Pfund pro Stunde. \
Wir sollten also in unsere Treatmentgruppe jene Mitarbeiter einschließen, die vor der Mindestlohneinführung einen Lohn unter 3.60£ erhielten. \
Da unser Datensatz allerdings keine Daten zu jedem Arbeitnehmer enthält, müssen wir uns der Wahl der Treatmentgruppe nähern. \
Die Variable, die den Lohn innerhalb eines Unternehmens am Besten widerspiegelt ist hierbei `avwage`, worüber sich auch im Artikel genähert wird. 

Dabei werden alle Unternehmen mit einem durchschnittlichen Lohn kleiner gleich **12,000£** in die Treatmentgruppe einsortiert. \
Um zu verstehen, warum sich für diesen Wert als Obergrenze entschieden wird ist es hilfreich, den Wert in Zusammenhang mit dem Stundenlohn zu bringen.

Dazu soll zunächst der durchschnittliche Lohn aller Unternehmen aus der Treatmentgruppe in der Pre-Policy Periode im Jahr **1999** ermittelt werden.

**Aufgabe**: Setzen Sie die passenden Werte in die Lücken ein. *Hinweis*: `avwage` wird im Datensatz in 1000 Pfund angegeben
```{r}
#< fill_in
mean_treat = dat %>%
  filter(avwage <= ___) %>%
  filter(year == ___) %>%
  summarise(round(mean(avwage)*1000,2))
mean_treat
#>
mean_treat = dat %>%
  filter(avwage <= 12) %>%
  filter(year == 1999) %>%
  summarise(round(mean(avwage)*1000,2))
mean_treat
```

Dieser Wert gibt den durchschnittlichen Jahreslohn der Treatmentgruppe wieder.\
Um nun auf den Stundenlohn zu kommen, müssen wir ermitteln, in welchem Bereich sich die Jahresarbeitszeit im Geschäftsjahr mit dem Ende in 1999 befindet.

Daten aus dem [OECD Employment Outlook 2002](https://doi.org/10.1787/empl_outlook-2002-en)
zeigen, dass die durchschnittliche Jahresarbeitszeit 1998 bei **1731 Stunden** und 1999 bei **1719 Stunden** liegt. \
Dabei werden alle Beschäftigten gleichermaßen berücksichtigt, unabhängig von der Art der Anstellung.

Daraus können wir folgende Jahresarbeitszeit abschätzen, wobei wir approximiert die Daten aus den Jahren 1998 und 1999 verwenden:

**Aufgabe**: Summieren Sie anteilsmäßig 3/4 der durchschnittlichen Arbeitszeit aus dem Jahr **1998** und 1/4 aus dem Jahr **1999** und speichern den Wert in der entsprechenden Variablen.
```{r}
#< fill_in
annual_hours = 0.75*___ + 0.25*___
#>
annual_hours = 0.75*1731 + 0.25*1719
```

Nun haben wir den genäherten Wert, wollen ihn allerdings auf eine Vollzeitbeschäftigung anwenden. 

**Aufgabe:**Ermitteln Sie den Anteil an Teilzeitarbeitern (`ptwk`) in unserem Datensatz `dat`. \
(*Hinweis*: Da es immer sein kann, dass Daten nicht vollständig sind, fügen wir `na.rm = TRUE` hinzu, um fehlende Einträge bei der Berechnung zu ignorieren.)
```{r}
#< fill_in
ptwk_share = mean(___, na.rm = TRUE)
ptwk_share
#>
ptwk_share = mean(dat$ptwk, na.rm = TRUE)
ptwk_share
```

Der Anteil an Teilzeitarbeitern beträgt in unserem Datensatz ca. 16.4%. \
Um eine imaginäre Vollzeitbeschäftigung darzustellen, verdoppeln wir jene Jahresarbeitszeiten der Teilzeitarbeiter und fügen diese der bereits errechneten durchschnittlichen Jahresarbeitszeit hinzu.

**Aufgabe:** Lassen Sie sich die approximierte durchschnittliche Jahresarbeitszeit mittels *check* ausgeben.
```{r}
#< task
annual_hours = annual_hours + ptwk_share * annual_hours

annual_hours
#>
```

Nun können wir den durchschnittlichen Stundenlohn innerhalb der Treatmentgruppe darstellen.

**Aufgabe:** Berechnen Sie den durchschnittlichen Stundenlohn der Treatmentgruppe.
```{r}
#< fill_in
treat_wage_hour = mean_treat / ___
treat_wage_hour
#>
treat_wage_hour = mean_treat / annual_hours
treat_wage_hour
```


Mit dieser Näherung kommt man in die Nähe des Mindestlohns. Dennoch ist dies auch mit Vorsicht zu genießen. \
Da die Wahl der Treatmentgruppe auf Durchschnittslöhne eines gesamten Unternehmens beruht, können große Ausreißer das Ergebnis beeinflussen. \
Unsere Näherung beruht auf mehreren Annahmen, die nicht vollumfänglich belegt werden können. \
Nicht alle vom Mindestlohn profitierenden Arbeitnehmer werden in der Treatmentgruppe abgebildet. \
Dennoch kommen die Autoren zu dem Schluss, dass mit 87% jener Arbeitnehmer Teil der Treatmentgruppe sind. \
*(vgl. Draca et al., S. 137f.)*


Nun haben wir im ersten Schritt die Gruppen und Perioden definiert. Als nächstes werden wir die Daten aktiv den jeweiligen Gruppen zuordnen und zusammenfassen.



## Exercise 3.2 händische DiD-Berechnung

Mit einem Blick auf den Datensatz erkennt man, dass für die unterschiedlichen Gruppen bereits Dummy-Variablen erstellt worden sind.

**Aufgabe**: Laden Sie erneut den bereits bekannten Datensatz mittels *check*.
```{r}
#< task
dat = read_dta('main_fame.dta')
#>

```

 
Erstellen Sie auf Basis des Datensatzes `dat` eine Tabelle, die alle relevanten Daten für eine händische Berechnung enthält.

**Aufgabe:** Führen Sie den folgenden Code aus, indem Sie den Datensatz nach den für die DiD-Schätzung relevanten Variablen gruppieren.
```{r}
#< fill_in
dat_table_DiD = dat %>%
  ___(ctreat1, NMW)%>%
  filter(pp == 1) %>%
  summarise(mean_avwage = mean(avwage), mean_ln_avwage = mean(ln_avwage), mean_net_pcm = mean(net_pcm))
#>
dat_table_DiD = dat %>%
  group_by(ctreat1, NMW)%>%
  filter(pp == 1) %>%
  summarise(mean_avwage = mean(avwage), mean_ln_avwage = mean(ln_avwage), mean_net_pcm = mean(net_pcm))
```

#< quiz "3.2.1"
question: Wieso wird der Mittelwert verwendet und nicht nur die beiden Jahre vor und nach der Mindestlohneinführung? 
sc:
    - Durch die Betrachtung können kurzfristige Schwankungen und zufällige Effekte abgefedert werden.*
    - Um einen deutlicheren Unterschied zwischen den beiden Perioden zu erhalten.

success: Richtige Antwort. Bei der Difference in Differences Schätzung ist es hilfreich einen größeren Zeitraum zu betrachten. Die reine Veränderung des Ergebnisses, worauf Antwort B abzielt, sollte kein Grund bei statistischen Analysen sein.
failure: Das ist nicht korrekt. 
#>

Wenn Sie sich den obigen Code nochmals ansehen, können Sie eine noch nicht eingeführte Variable erkennen. \
Der Datensatz wird hier anhand der Variablen "pp" gefiltert.

#< quiz "3.2.2"
question: Wieso und nach welchem Kriterium könnte hier gefiltert werden? 
sc:
    - Es gibt starke Unterschiede in der Berichterstattung zwischen den Ländern im UK. Daher fokussieren wir uns auf England.
    - Aufgrund einer höheren Teilzeitquote bei Frauen, filtern wir hier nach Geschlecht und legen den Fokus auf die Männer.
    - Da kleinere Firmen von manchen Teilen der Berichterstattung befreit sind, sind ihre Daten unvollständig. Daher werden sie nicht weiter berücksichtigt.* 

success: Richtige Antwort. Diese Vorauswahl wird von Seiten der Autoren getroffen.
failure: Diese Antwort ist leider falsch. 
#>

Im Vereinigten Königreich sind kleinere Unternehmen von der Veröffentlichung bestimmter Daten befreit. \
Um eine vollumfängliche Analyse zu gewährleisten, entscheiden sich die Autoren daher ein Unterbeispiel zu erstellen, in denen Daten vollständig erfasst werden *(vgl. Draca et al., S. 135, Verw. 13)*. \
Das schränkt allerdings auch die Bewertung ein, lenkt den Blick weg von kleineren Unternehmen und muss bei der Betrachtung der Ergebnisse bedacht werden. \
Wie die Autoren die Auswahl des Unterbeispiels treffen wird nicht leider vollumfänglich bekannt und auch eigene Überlegungen lassen nur Mutmaßungen zu (vgl. Anhang 1).

------

Nachdem die relevanten Daten des DiD zusammengefasst in der Tabelle `dat_table_DiD` vorhanden sind, können die Differenzen nun händisch berechnet werden.

Die Formel hierfür lautet 
$$(y.post.treat - y.pre.treat) - (y.post.control - y.pre.control)$$
*(vgl. Draca et al., S. 133)*

Der erste Teil beschreibt die Veränderung in der Treatmentgruppe durch das Treatment der Mindestlohneinführung. Um andere Einflussfaktoren wie saisonale Effekte herauszurechnen, wird im zweiten Teil die Veränderung in der Kontrollgruppe berechnet, welche im Idealfall nicht vom Treatment betroffen ist.

Werfen Sie zunächst einen Blick auf die erzeugte Tabelle und überlegen Sie, welcher Gruppe die jeweiligen Werte angehören. 

**Aufgabe:**Lassen Sie sich die oben erstellte Tabelle `dat_table_DiD` anzeigen und überprüfen Sie Ihre Eingabe mittels *check*.
```{r}
#< task

#>
dat_table_DiD
```

#< quiz "3.2.3"
question: Welche Spalte beschreibt die Kontroll- bzw. Treatmentgruppe?
sc:
    - ctreat1*
    - NMW

success: Richtige Antwort. Ist ctreat1 = 1, so handelt es sich um die Treatmentgruppe, andernfalls ist es die Kontrollgruppe.
failure: Falsch. `NMW` bezieht sich auf den Zeitpunkt. 
#>

#< quiz "3.2.4"
question: Von welcher Gruppe ist die Rede, wenn `NMW = 1` ?
sc:
    - Pre-Treatment
    - Post-Treatment*
    
success: Korrekt. In diesem Fall befinden wir uns im Jahr 2000 oder später.
failure: Das ist nicht richtig. In diesem Fall wäre `NMW = 0`.

#>


**Aufgabe**: Weisen Sie den für die DiD Schätzung relevanten Variablen die passenden Tabelleneinträge aus `dat_table_DiD` zu.
```{r}
#< fill_in
y1.post.treat = dat_table_DiD$mean_ln_avwage[___]
y1.post.control = dat_table_DiD$mean_ln_avwage[___]
y1.pre.treat = dat_table_DiD$mean_ln_avwage[___]
y1.pre.control = dat_table_DiD$mean_ln_avwage[___]

#>
y1.post.treat = dat_table_DiD$mean_ln_avwage[4]
y1.post.control = dat_table_DiD$mean_ln_avwage[2]
y1.pre.treat = dat_table_DiD$mean_ln_avwage[3]
y1.pre.control = dat_table_DiD$mean_ln_avwage[1]

```

Neben des logarithmierten Durchschnittslohns wird auch der DiD-Schätzer der Nettorendite eines Unternehmens je Geschäftsjahr (`net_pcm`) berechnet. \
Das geschieht analog zur obigen Schätzung.

**Aufgabe**: Werfen Sie erneut einen Blick auf die erstellte Tabelle und geben Sie nun die Zeilen ein, in denen der passende Wert steht.
```{r}
#< fill_in
y2.post.treat = dat_table_DiD$mean_net_pcm[___]
y2.post.control = dat_table_DiD$mean_net_pcm[___]
y2.pre.treat = dat_table_DiD$mean_net_pcm[___]
y2.pre.control = dat_table_DiD$mean_net_pcm[___]
#>
y2.post.treat = dat_table_DiD$mean_net_pcm[4]
y2.post.control = dat_table_DiD$mean_net_pcm[2]
y2.pre.treat = dat_table_DiD$mean_net_pcm[3]
y2.pre.control = dat_table_DiD$mean_net_pcm[1]
```

Die Werte sind nun gespeichert und die DiDs können berechnet werden.

**Aufgabe**: Fügen Sie dem Code das Anzeigen der Ergebnisse hinzu und führen Sie den Code mittels *check* aus.
```{r}
#< fill_in
DiD_ln_avwage = (y1.post.treat - y1.pre.treat) - (y1.post.control - y1.pre.control)
DiD_net_pcm = (y2.post.treat - y2.pre.treat) - (y2.post.control - y2.pre.control)
  
#Ergebnisse anzeigen

#>
DiD_ln_avwage = (y1.post.treat - y1.post.control) - (y1.pre.treat - y1.pre.control)
DiD_net_pcm = (y2.post.treat - y2.post.control) - (y2.pre.treat - y2.pre.control)
  
#Ergebnisse anzeigen
DiD_ln_avwage
DiD_net_pcm
```

#< award "DiD Starter-Set"
Sie haben erfolgreich eine erste Difference-in-Differences Schätzung durchgeführt und können die unterschiedlichen Gruppen in richtiger Relation zueinander betrachten. 
#>

Durch die Einführung des Mindestlohns können wir sagen, dass dadurch in den beobachteten Unternehmen der Durchschnittslohn gestiegen ist. \
Zugleich ist zu erkennen, dass in jenen Unternehmen der Nettogewinn zurück gegangen ist.

Um diese Veränderung genauer bewerten zu können und tiefergehende Analysen zu ermöglichen, machen wir uns die Methode der Regression zu eigen.


## Exercise 3.3 DiD-Schätzung mittels Regression

**DAG**

Zu Beginn widmen wir uns der Veränderung im Durchschnittslohn durch die Einführung des Mindestlohns.
Um uns einen ersten Überblick über die Zusammenhänge der Variablen in unserer DiD-Schätzung zu verschaffen, sind die Directed Acyclic Graphs (DAGs) von Vorteil.

#< info "DAG"
In einem DAG werden unterschiedliche Variablen durch Pfade in Form von Pfeildarstellungen in Relation zueinander gesetzt. \
Eine solchen Darstellung kann die Aufstellung von Regressionen veraunschaulichen und nachvollziehbar machen. \
Interessant dabei sind die sogenannten Confounder, die sowohl die abhängige, als auch eine beschreibende Variable beeinflussen. \
(vgl. International Journal of Epidemiology, 2021, Vol. 50, No. 2, S. 622)
(https://academic.oup.com/ije/article/50/2/620/6012812) 

Erklärungen, wie ein DAG in R zustande kommt: \
https://cran.r-project.org/web/packages/ggdag/vignettes/intro-to-dags.html \
https://r-causal.github.io/ggdag/
#>

**Aufgabe**: Führen Sie hierfür den Code mittels *check* aus und sehen Sie sich den Graphen an.
```{r}
#< task
dag <- dagify(
  ln_avwage ~ ctreat1 + treat1_NMW + NMW, 
  treat1_NMW ~ ctreat1 + NMW,
  labels = c(ctreat1 = "ctreat1", treat1_NMW = "treat1_NMW", NMW = "NMW", ln_avwage = "ln_avwage")
)

ggdag(dag, node_size = 6, text = FALSE, edge_type = "link", use_labels = "label")+
  theme_dag_blank()
#>
```

Hier sieht man wie die Variablen, mit denen wir bisher gearbeitet haben, zusammenhängen.

#< quiz "3.3.0"
question: Wählen Sie den/die Confounder aus unserem DAG aus?
sc:
    - ln_avwage
    - treat1_NMW & ln_avwage
    - NMW & ctreat1*
    - NMW & treat1_NMW & ctreat1

success: Korrekt. Die Variablen beeinflussen sowohl die abhängige Variable `ln_avwage`, als auch die erklärende Variable `treat1_NMW`
failure: Das ist leider falsch. Schauen Sie, von welcher Variablen zwei Pfeile ausgehen.
#>

Wir können aus dem DAG eine Regressionsgleichung der Form $ln(avwage) = \beta_0 + \beta_1 Variable_1 + \beta_2 Variable_2 + \beta_3 Variable_3 + \epsilon$ ableiten.

Dabei kann jedem Schätzer $\hat\beta_i$ eine beschreibende Eigenschaft zugewiesen werden.

|. Schätzer     .|.  Erklärende Variable   .|. Eigenschaft                              .|. Confounder? .|
|:--------------:|:------------------------:|:------------------------------------------:|:-------------:|
| $\hat\beta_1$  |  $ctreat$                | Generelle Unterschiede vor dem Treatment   |  Ja           |
| $\hat\beta_2$  |  $treat1 * NMW$          | DiD-Schätzer                               |  Nein         |
| $\hat\beta_3$  |  $NMW$                   | Saisonale Effekte                          |  Ja           |

\

**Aufgabe:** Aus dieser Darstellung soll nun eine quantitative Analyse ermöglicht werden. Lesen Sie dafür einen Auszug des bekannten Datensatzes `main_fame` ein, indem Sie den Code mit *check* ausführen.
```{r}
#< task
dat_raw = read_dta('main_fame.dta')
dat = filter(dat_raw, pp == 1) 
#>
```

Zu Beginn unserer Analyse wollen wir mehrere Regressionen auf Basis der oben im DAG dargestellten Variablen laufen lassen. \
Dazu sollen die einzelnen Variablen, die `ln_avwage` beeinflussen, beobachtet werden.

#< info "stargazer"
Die Stargazer Funktion ermöglicht uns einen schön formatierten Output mit der Möglichkeit, mehrere Regressionen parallel darzustellen.

(https://www.rdocumentation.org/packages/stargazer/versions/5.2.3/topics/stargazer)
#>

**Aufgabe**: Führen Sie die Regression mit unserem DiD-Schätzer aus und stellen Sie das Ergebnis mittels der `stargazer`Funktion dar.
```{r}
#< fill_in
regi = lm(ln_avwage ~ treat1_NMW, data = dat)

stargazer(___, type = "text")
#>
regi = lm(ln_avwage ~ treat1_NMW, data = dat)

stargazer(regi, type = "text")
```

#< quiz "3.3.1"
question: Wieso ist der Einfluss der Treatmentvariablen im Gegensatz zur händischen Berechnung negativ?
sc:
    - Die Regression ist genauer als die händische Berechnung.
    - Die Regression ist unvollständig.*

success: Korrekt. Da `treat1_NMW` von zwei Confoundern beeinflusst wird, wird der Effekt von `treat1_NMW` in der Regression verschätzt.
failure: Das ist in diesem Fall nicht der Grund für die Unterschiede. Stichwort Confounder, sehen Sie sich den DAG an.
#>

Wir müssen in unserer Regression also sowohl die Interaktionsvariable als auch die dazugehörigen Confounder berücksichtigen.


Daraus folgt dann folgende Regressionsgleichung:
$$ln(avwage) = \beta_0 + \beta_1 ctreat + \beta_2 treat1*NMW + \beta_3 NMW + \epsilon$$


*Aufgabe*: Berechnen Sie auf Basis dieser Gleichung die Einflüsse der Variablen und das damit zusammenhängende DiD-Ergebnis. 
Stellen Sie das Ergebnis wieder in `stargazer` dar.
```{r}
#< fill_in
reg1 = lm(ln_avwage ~ ___ + ___ + ___, data = dat)
stargazer(reg1, type = "text")
#>

reg1 = lm(ln_avwage ~ ctreat1 + treat1_NMW + NMW, data = dat)
stargazer(reg1, type = "text")
```

Der Wert der Interaktionsvariablen hat sich im Vergleich zur unvollständigen Regression stark verändert und erinnert an die händische Berechnung. \
Um diese starke Veränderung besser zu verstehen, können wir die gemeinsame Betrachtung der erklärenden Variablen mit der einzelnen Betrachtung vergleichen.

**Aufgabe**: Führen Sie dazu den Code aus und sehen sich die Ausgabe an.
```{r}
#< task
regii = lm(ln_avwage ~ ctreat1, data = dat)

regiii = lm(ln_avwage ~ NMW, data = dat)

stargazer(regi, regii, regiii, reg1, type = "text")
#> 
```

Im Gegensatz zur händischen Berechnung können wir durch die Regression die Signifikanz unserer Schätzung beurteilen.

#< quiz "3.3.3"
question: Wie beurteilen Sie die Signifikanz unseres DiD-Schätzers in der dargestellten Regression?
sc:
    - hoch*
    - niedrig

success: Korrekt, *** bestätigt ein hohes Signifikanzniveau. 
failure: Das ist nicht richtig. Achten Sie auf die p-Werte und die dazugehörige Veranschaulichung durch Sterne.
#>


Die Werte der Variablen sind im obigen Fall also hoch signifikant gekennzeichnet. \
Allerdings können die p-Werte fehlerhaft sein, da es sich bei den Daten teilweise um **genestete Daten** handelt. 

Genestete Daten liegen vor, wenn mehrere Daten zu einer übergeordneten Einheit zählen. \
*(vgl. Aarts et al. (2014), S. 491)*

In unserem Fall haben wir Daten zum logarithmierten Durchschnittslohn (`ln_avwage`) über mehrere Jahre. Diese haben ein Unternehmen (`regno`) als übergeordnete Einheit. \
Um Fehler bezüglich genesteter Daten zu verhindern, führen wir **Clusterrobuste Standardfehler** ein.

#< quiz "3.3.4"
question: Nach welcher Variablen soll geclustert werden?
sc:
    - ln_avwage
    - regno*

success: Korrekt, hierbei handelt es sich um die übergeordnete Einheit, nach der geclustert werden muss.   
failure: Das ist so nicht richtig. Bei genesteten Daten muss nach der übergeordneten Einheit geclustert werden.
#>

Nun fügen wir die Clusterrobusten Standardfehler in unsere Regression ein und schauen, was sich dadurch verändert.\
Führen Sie hierzu die Regression mithilfe der `felm` Funktion durch und vergleichen die Regression ohne Clustering (`reg1`) mit der Regression mit Clustering. 

#< info "felm"
Im Vergleich zu einem einfachen Regressionsmodell mit `lm`, kann durch die `felm` Funktion eine spezifiziertere Regression durchgeführt werden.\
Der Grundaufbau des formulas sieht wie folgt aus: \
**felm(y ~ abhängige Variablen | ausgeschlossene Variablen | Spezifikation einer Instrumentalviariablen | Clusterspezifikation)** \
(https://www.rdocumentation.org/packages/lfe/versions/2.9-0/topics/felm)
#>

**Aufgabe**: Tragen Sie die Clusterspezifikation nach der Variablen `regno` an die passende Stelle ein und setzen die ungenutzten Spezifikationen gleich 0.
```{r}
#< fill_in
reg2 = felm(ln_avwage ~ ctreat1 + treat1_NMW + NMW | ___ | ___ | ___, data=dat)
stargazer(reg1, reg2, type ="text")
#>
reg2 = felm(ln_avwage ~ ctreat1 + treat1_NMW + NMW | 0 | 0 | regno, data=dat)
stargazer(reg1, reg2, type ="text")
```


An den Werten der Schätzer ist keine Veränderung zu erkennen. Allerdings haben sich die Werte der Standardfehler verändert. \
Während man für die Schätzer von `ctreat1` und der Interaktionsvariablen `treat1_NMW` eine Erhöhung des p-Wertes vorfindet, ist eine Verringerung beim Schätzer der Variablen `NMW` zu verzeichnen.

Durch die Verwendung von clusterrobusten Standardfehlern wird eine Korrelation der Fehlerterme innerhalb einer Gruppe hergestellt. \
Wenn eine beschreibende Variable innerhalb der Gruppe nicht so stark variiert, kann es sein, dass der Standardfehler in einer Regression ohne clusterrobuste Standardfehler höher ausfällt als er eigentlich ist. \
*(vgl. Angrist et al. (2008), S. 231ff.)*



**Aufgabe:** Betrachten wir nochmal das Ergebnis der aktuellsten Regression, ausführbar mittels *check*:
```{r}
#< task
stargazer(reg2, type = "text")
#>
```

Die Schätzer der Variablen beschreiben die Veränderungen im Vergleich zum Pre-Policy Jahr, welche mit `Constant` beschrieben wird.

#< quiz "3.3.5"
question: Wie beschreiben Sie den Wert des Schätzers der DiD-Variablen `treat1_NMW`?
sc:
    - Der Anstieg des Lohns in der Treatmentgruppe ist um ca. 0.11 Pfund höher als in der Kontrollgruppe.
    - Der Anstieg des Lohns in der Treatmentgruppe ist um ca. 11 Prozent höher als in der Kontrollgruppe.
    - Der Anstieg des Lohns in der Treatmentgruppe ist um ca. 11 Prozentpunkte höher als in der Kontrollgruppe.*

success: Richtige Antwort. Der Durchschnittslohn als abhängige Variable ist logarithmiert dargestellt.
failure: Das ist leider falsch. Achten Sie darauf, wie die abhängige Variable dargestellt wird.
#>


Wir haben in Erfahrung gebracht, dass es einen Effekt durch die Einführung des gesetzlichen Mindestlohns gibt. \
Um herauszufinden, wie die Unternehmen auf diese Veränderung reagieren, sehen wir uns spiegelbildlich zur obigen Schätzung die Veränderung auf die Gewinnmarge `net_pcm` an.

**Aufgabe**: Führen Sie den untenstehenden bekannten Code mit einer angepassten abhängigen Variablen aus und lassen Sie sich das Ergebnis mittels `stargazer` ausgeben.
```{r}
#< fill_in
reg3 = felm(___ ~ ctreat1 + treat1_NMW + NMW | 0 | 0 | regno, data = dat)

stargazer(___, type = "text")
#>
reg3 = felm(net_pcm ~ ctreat1 + treat1_NMW + NMW | 0 | 0 | regno, data = dat)

stargazer(reg3, type = "text")
```

Wir erkennen, dass die Schätzer signifikante Werte aufweisen und sehen somit, dass unsere zu Beginn von Hand berechneten Werte auch statistisch belastbar sind.\
Auch hier dürfen Sie den Schätzer unserer DiD-Vairablen wieder interpretieren.

#< quiz "3.3.6"
question: Was passiert mit der Gewinnmarge, wenn man die Schätzung `reg3` als Basis wählt?
sc:
    - Durch die Mindestlohneinführung ist die Gewinnmarge in Unternehmen der Kontrollgruppe um 2.7 Prozent stärker gesunken.
    - Durch die Mindestlohneinführung ist die Gewinnmarge in Unternehmen der Treatmentgruppe um 2.7 Prozentpunkte stärker gesunken.*
    - Durch die Mindestlohneinführung ist die Gewinnmarge in Unternehmen der Kontrollgruppe um 2.7 Prozentpunkte stärker gesunken.

success: Richtige Antwort. 
failure: Leider falsch. Wieso sollte die Marge geringer sein, wenn die Gruppe - vereinfacht dargestellt - doch gar nicht vom Treatment betroffen ist?
#>

#< award "Earl of DiD"
Sie haben die händische Schätzung erfolgreich in eine statistisch belastbare Schätzung überführt und können die Ergebnisse der Regressionen bewerten.
#>

-------------


Als nächsten Schritt sehen wir uns weiter an ob es zu Veränderungen kommt, wenn wir auf bestimmte Effekte der Unternehmenswelt kontrollieren. \
Dafür können wir uns die Funktion der **Faktorvariablen** zunutze machen.

Da wir bei nominalskalierten Daten keine Möglichkeit zur messbaren Unterscheidung finden, müssen wir Faktorvariablen nutzen, um diskrete Daten in die Regression miteinzubeziehen. \
Technisch umsetzbar wird diese Faktorisierung, indem eine Gruppe die Referenz bildet. Statistisch gesehen geht diese Wahl willkürlich vonstatten, inhaltlich gibt es nach Hardy (1993) drei Grundüberlegungen zur Wahl der Referenzgruppe:

So soll die Referenzgruppe

**1. Einen sinnvollen Vergleich bieten** \
**2. Klar definiert sein** \
**3. Eine ausreichend große Stichprobengröße im Vergleich zu anderen Gruppen besitzen**

*(vgl. Cohen et al. (2002), S.302ff.)*


#< info "factor"
In R können wir entweder die Variablen innerhalb der Regression faktorisieren, oder bereits im Datensatz.
#>

**Aufgabe:** Die Variable `year` möchten wir in unserem Datensatz faktorisieren und erstellen hierfür eine neue Variable `factor_year`. Vergleichen Sie weiter die Werte der neuen mit der bereits existierenden Variablen, indem Sie sich mittels `head()` die ersten Einträge anzeigen lassen.
```{r}
#< fill_in
dat = dat %>%
  mutate("___" = factor(year))

___(dat$year)
___(dat$factor_year)
#>
dat = dat %>%
  mutate("factor_year" = factor(year))

head(dat$year)
head(dat$factor_year)
```

Die Einträge scheinen zunächst identisch, dennoch ist bei unserer faktorisierten Variablen der Eintrag *Levels* zu finden. \
*Levels* gibt die unterschiedlichen Kategorien innerhalb der Variablen an. Dabei stellt die erste Kategorie die Referenzkategorie dar.

#< quiz "3.3.7"
question: Wie bewerten Sie die gewählte Referenzkategorie? (Denken Sie dabei an die oben beschriebenen Grundüberlegungen)
sc:
    - Das Jahr 1997 ist sinnvoll gewählt, da es den Startpunkt unserer Analyse markiert. 
    - Es gibt andere Jahre, die auf Basis unserer Analyse einen wichtigeren Punkt markieren*
    - Alle Jahre sind gleich relevant und die Grundüberlegungen treffen auf jedes Jahr zu. Daher kann das Jahr beliebig gewählt werden.

success: Richtige Antwort. R wählt automatisch den kleinsten Wert bei der Faktorisierung, ohne Berücksichtigung der Relevanz.
failure: Das ist so nicht korrekt, überlegen Sie nochmal auf welche Jahre wir bei unserer DiD-Schätzung einen besonderen Fokus gelegt haben.
#>

Eine besser geeignete Referenzkategorie können wir selbst festlegen. \
**Aufgabe**: Wählen Sie das Jahr 2000 als Referenzwert für unsere Faktorisierung.
```{r}
#< fill_in
dat$factor_year = relevel(dat$factor_year, ref = "___")
#>
dat$factor_year = relevel(dat$factor_year, ref = "2000")
```

Sehen wir uns nun an, was diese Faktorisierung für die Regression bedeutet, indem wir die Regression einmal mit `year` und einmal mit `factor_year` ergänzen. \
**Aufgabe**: Geben Sie den Vergleich der unterschiedlichen Regressionen aus, indem Sie den Code mittels *check* ausführen.
```{r}
#< task
reg3 = felm(net_pcm ~ ctreat1 + treat1_NMW + NMW | 0 | 0 | regno, data = dat)
reg3.1 = felm(net_pcm ~ ctreat1 + treat1_NMW + NMW + year| 0 | 0 | regno, data = dat)
reg3.2 = felm(net_pcm ~ ctreat1 + treat1_NMW + NMW + factor_year| 0 | 0 | regno, data = dat)
reg3.3 = felm(net_pcm ~ ctreat1 + treat1_NMW + NMW + factor(year)| 0 | 0 | regno, data = dat)


stargazer(reg3, reg3.1, reg3.2, reg3.3, type= "text")
#>
```

Man sieht, dass sich die Ergebnisse durch eine Faktorisierung verändern. \
Auch durch die Veränderung der Referenzkategorie entstehen Unterschiede, wenn auch im überschaubaren Rahmen. 

Dabei gilt dennoch zu erwähnen, dass die Autoren des Artikels bei der Wahl der Referenzkategorie wohl einer anderen Idee der Wahl gefolgt sind und das Jahr 1997 als Referenz gewählt haben. 

Da durch die Darstellung der Faktorvariablen eine längere Ausgabe entsteht, kann es beim Hinzufügen mehrerer Faktorvariablen aus Gründen der Übersichtlichkeit und Vergleichbarkeit sinnvoll sein, unsere Ausgabe auf das Relevanteste reduzieren.

Hierbei lernen Sie eine alternative Darstellung der Regressionsergebnisse zu `stargazer` kennen.

**Aufgabe:** Laden Sie zunächst das Paket `broom`.
```{r}
#< fill_in
library(___)
#>
library(broom)
```

**Aufgabe**: Führen Sie den Code aus, um aus der Liste - die uns durch die `felm`Funktion erstellt wird - eine Tabelle der Regression zu kreieren. Geben Sie dabei anschließend die Tabelle aus.
```{r}
#< fill_in
table_reg3.3 = tidy(reg3.3)

#Tabelle ausgeben

#>
table_reg3.3 = tidy(reg3.3)

#Tabelle ausgeben
table_reg3.3
```

Nun haben wir die relevanten Werte der Regression in der Tabelle gespeichert und können darauf wie auf jeden anderen Data Frame zurückgreifen.

#< award "tidy broomer"
Glückwunsch, Sie haben die Regressionsausgaben erfolgreich in einer Tabelle gespeichert.
Um mehr über das broom Paket zu erfahren, geht es [hier](https://cran.r-project.org/web/packages/broom/vignettes/broom.html) entlang.
#>

**Hinweis:** Das Tool wird genutzt, um einen besseren Überblick über die Veränderung durch Variablen zu erhalten. Es dient als Hilfsmittel und nicht als genereller Mechanismus, um Regressionsergebnisse zu analysieren. \
In Anhang 2 können Sie sich die vollständigen Ausgaben der Regressionsergebnisse ausgeben lassen.

-----------

Nachdem wir nun die technischen Voraussetzungen geschaffen haben, können wir fachlich fortfahren und unsere Schätzung durch das Hinzufügen weiterer möglich beeinflussende Variablen präzisieren. \
Es geht darum zu überprüfen, ob die Veränderung der Unternehmensgewinne wirklich auf die Einführung des Mindestlohns zurückgeht und ob weitere Faktoren die Gewinnmarge eines Unternehmens beeinflussen können. \
Dabei prüfen wir auf unternehmens-, branchen- und ortsspezifische Größen.

**Aufgabe:** Führen Sie die Regressionen mittels *check* aus.
```{r}
#< task
reg4 = felm(ln_avwage ~ ctreat1 + treat1_NMW + NMW + grad2 + unionmem + ptwk + female + 
                factor(sic2) + factor(year) + factor(gorwk)| 0 | 0 | regno, data = dat)

reg5 = felm(net_pcm ~ ctreat1 + treat1_NMW + NMW + grad2 + unionmem + ptwk + female + 
                factor(sic2) + factor(year) + factor(gorwk)| 0 | 0 | regno, data = dat)
#>
```


Das waren sehr viele Regressionen, da kann es manchmal kompliziert sein den Überblick zu behalten. \
Um die wichtigsten Ergebnisse knapp zusammenfassen zu können, gibt es die Möglichkeit einzelne Werte aus den jeweiligen Regressionen auszuwählen und sie dann in einer Tabelle gegenüberzustellen. \
Dabei sehen wir uns die Veränderung des Kernergebnisses an.

**Aufgabe:** Um Ergebnisse auslesen zu können, wenden Sie ihre vorher erworbenen Kenntnisse zur Überführung von Regressionen in eine Tabelle an. 
```{r}
#< fill_in
tidy_reg1 = ___(reg1)
tidy_reg2 = ___(reg2)
tidy_reg3 = ___(reg3)
tidy_reg4 = ___(reg4)
tidy_reg5 = ___(reg5)
#>
tidy_reg1 = tidy(reg1)
tidy_reg2 = tidy(reg2)
tidy_reg3 = tidy(reg3)
tidy_reg4 = tidy(reg4)
tidy_reg5 = tidy(reg5)
```

**Aufgabe**: Erzeugen Sie zunächst die gegenüberstellende Tabelle der Regression ohne und mit Kontrollvariablen mittels *check* und lassen Sie sie ausgeben. Runden Sie die Ergebniss dabei auf drei Nachkommastellen
```{r}
#< fill_in
reg_table_ln_avwage = data.frame("Variable" = "treat1_NMW","Schätzer_reg2" = round(tidy_reg2$estimate[3],___),"se_reg2"= round(tidy_reg2$std.error[3],___), "Schätzer_reg4" = round(tidy_reg4$estimate[3],___), "se_reg4"= round(tidy_reg4$std.error[3],___))

reg_table_ln_avwage
#>
reg_table_ln_avwage = data.frame("Variable" = "treat1_NMW","Schätzer_reg2" = round(tidy_reg2$estimate[3],3),"se_reg2"= round(tidy_reg2$std.error[3],3), "Schätzer_reg4" = round(tidy_reg4$estimate[3],3), "se_reg4"= round(tidy_reg4$std.error[3],3))

reg_table_ln_avwage
```

Der positive Effekt der Mindestlohneinführung auf die Löhne der Treatmentgruppe ist weiterhin erkennbar, hat sich etwas verringert und ist weiterhin signifikant. \
Zudem wirkt die Wahl der erklärenden Variablen sinnvoll, da sie einen signifikanten Einfluss auf den Lohn haben. *(vgl. Anhang 2.1)*


Sehen wir uns das Ganze auch noch für die Veränderung in der Gewinnmarge an. \
**Aufgabe:** Führen Sie den Code mittels *check* aus.
```{r}
#< task
reg_table_net_pcm = data.frame("Variable" = "treat1_NMW","Schätzer_reg3" = round(tidy_reg3$estimate[3],3),"se_reg3"= round(tidy_reg3$std.error[3],3), "Schätzer_reg5" = round(tidy_reg5$estimate[3],3), "se_reg5"= round(tidy_reg5$std.error[3],3))

reg_table_net_pcm
#>
```

Auch hier können wir feststellen, dass unsere Schätzung weiter an Robustheit gewinnt und dadurch unsere These der Verringerung des Gewinnmarge durch die Mindestlohneinführung weiter aufrechterhalten werden kann.

## Exercise 3.4 Weiterführende Analysen

Neben den von uns dargestellten Ergebnissen, gibt es im untersuchten Artikel weitere interessante Darstellungen, die unsere bisherige Analyse zu den Auswirkungen auf Unternehmen im Niedriglohnsektor untermauern und erweitern.

### Placebo-Experiment

Durch die Einführung eines Placebo-Experiments wird festgestellt, dass es vor der Mindestlohneinführung keine relevanten Zusammenhänge zwischen der Treatment- und Kontrollgruppe bestanden. \
Teil dieses Experiments ist die Prüfung einer imaginären Mindestlohneinführung 3 Jahre vor der wahren Einführung. \
Dabei wurde kein Trend erkennbar, der auf einen bereits bestehenden Zusammenhang der beiden Gruppen schließen würde. \
*(vgl. Draca et al., S.142ff.)*

### Unterschied zwischen Industrien

Die Autoren vergleichen die Wirkung der Mindestlohneinführung Wettbewerben mit hoher und niedriger Marktmacht. \
Dabei kommen die Autoren zu dem Schluss, dass es Unterschiede im Umgang mit Mindestlohneinführungen gibt. \
Während Unternehmen mit einer verhältnismäßig geringen Marktmacht die Erhöhung der Löhne hauptsächlich über die Verringerung der Gewinnmarge kompensieren, ist zu erkennen, dass marktmächtige Unternehmen die Erhöhung durch Preisanpassungen an Kunden weitergeben. \
*(vgl. Draca et al., S.146f.)*

### Auswirkungen auf weitere Unternehmensfaktoren

Wie zu Beginn erwähnt könnten neben des Gewinns auch noch weitere Faktoren von der Einführung des nationalen Mindestlohns betroffen sein. \
Sowohl auf eine Veränderung am Arbeitsmarkt, als auch auf eine Veränderung in der Produktionskraft von nNternehmen werden keine signifikanten Einflüsse erkannt. \
Derweil ist ein langfristiger Trend zu erkennen der die Vermutung zulässt, dass es zu weniger Markteintritten in den stark vom der Mindestlohneinführung betroffen Unternehmen kommt. \
*(vgl. Draca et al., S.148f.)*


## Exercise 4  Einordnung des Artikels 

  
### Bewertung des Artikels

Die wissenschaftliche Arbeit von Draca et al. macht sich die besondere Eigenschaft des quasi-experimentellen Experiments zu eigen und wählt dazu passenderweise die Methodik der Difference-in-Differences Schätzung. \
Dabei zeigen die Autoren gut auf, dass die Einführung von Mindeslöhnen zu einer Veränderung der Unternehmensgewinne führt. \
Hinzu kommt, dass für die häufig untersuchte Frage der Veränderung in der Beschäftigung kein relevanter Effekt erkannt wird. \
Durch die Wahl von plausiblen Kontrollvariablen aus unterschiedlichen Bereichen der Unternehmenswelt wirkt die Argumentation fundiert. \
Der zunächst nicht evidenten Einteilung in Kontroll- und Treatmentgruppe wird sich genähert und anhand von Lohnstrukturen werden die Daten logisch nachvollziehbar eingeteilt. \
Kritisch anzumerken ist die Wahl der Beispieldatensätze. Hier wird wenig transparent argumentiert und eine klare Struktur der Idee der Selektion ist nicht erkennbar. \
Da wir keine genauen Daten für jeden Arbeitnehmer haben, wird ist unsere Analyse vor allem auf den Niedriglohnsektor anwendbar, wobei mit einem Anteil von 87% auch ein relativ großer Teil der Arbeiter abgebildet wird. \
Begleitend zeigt das eine Unternehmensstruktur auf, in der Lohnunterschiede vorallem zwischen Sektoren variieren und weniger innerhalb eines Unternehmens. \
Eine weitere Komponente, die im Rahmen der Analyse vermisst wird, ist eine finanzielle Rahmenbedingung als Kontrollvariable. \
Der Output des Unternehmens bleibt weitestgehend unberücksichtigt, da im Datensatz keine Daten zu Produkten wie Preise oder Qualität vorhanden sind. Diese Problematik ist auch den Autoren bewusst und sie weisen auf diese Einschränkung in der Bewertung hin. \

- Weitere Forschung
Höherer Rückgang in der Marge bei Unternehmen mit großer Marktmacht entdeckt
- Rückbezug zur Einleitung
- Ist ein Mindestlohn zu befürworten




## Exercise Anhang

### Anhang 1
Werfen wir einen Blick auf die aussortierten Daten und überprüfen anhand der Beschäftigungszahlen, ob es Aufffälligkeiten gibt:

```{r}
#< task
dat = read_dta('main_fame.dta')
dat_no_pp = dat %>%
  filter(pp == 0)

dat_pp = dat %>%
  filter(pp == 1)

boxplot(log(dat_no_pp$emp),log(dat_pp$emp))
boxplot(log(dat_no_pp$net_pcm),log(dat_pp$net_pcm))
boxplot(log(dat_no_pp$avwage),log(dat_pp$avwage))
boxplot((dat_no_pp$manuf),(dat_pp$manuf))
boxplot(log(dat_no_pp$turnemp),log(dat_pp$turnemp))

#>
```

Im Gesamten ist zu erkennen, dass die Daten, die sich nicht in der Auswahl befinden, breiter gestreut sind. \
Man erkennt einen Unterschied in den Beschäftigungszahlen der beiden Gruppen.

## Anhang 2

### Anhang 2.1
Regressionsergebnisse zum logarithmierten Durchschnittslohn:
```{r}
#< task
reg2 = felm(ln_avwage ~ ctreat1 + treat1_NMW + NMW | 0 | 0 | regno, data=dat_pp)

reg4 = felm(ln_avwage ~ ctreat1 + treat1_NMW + NMW + grad2 + unionmem + ptwk + female + 
                factor(sic2) + factor(year) + factor(gorwk)| 0 | 0 | regno, data = dat_pp)

stargazer(reg2, reg4, type ="text")
#>
```

### Anhang 2.2
Regressionsergebnisse zur Gewinnmarge:
```{r}
#< task
reg3 = felm(net_pcm ~ ctreat1 + treat1_NMW + NMW | 0 | 0 | regno, data = dat_pp)

reg5 = felm(net_pcm ~ ctreat1 + treat1_NMW + NMW + grad2 + unionmem + ptwk + female + 
                factor(sic2) + factor(year) + factor(gorwk)| 0 | 0 | regno, data = dat_pp)

stargazer(reg3, reg5, type = "text")
#>
```

## Exercise Referenzen

**Literatur**

- Aarts, E., Verhage, M., Veenvliet, J. V., Dolan, C. V., & Van Der Sluis, S. (2014). A solution to dependency: using multilevel analysis to accommodate nested data. Nature neuroscience, 17(4), 491-496.

- Abadie, A., Athey, S., Imbens, G. W., & Wooldridge, J. M. (2023). When should you adjust standard errors for clustering?. The Quarterly Journal of Economics, 138(1), 1-35.

- Angrist, J. D., & Pischke, J. S. (2009). Mostly harmless econometrics: An empiricist's companion. Princeton university press.

- Callaway, B., & Sant’Anna, P. H. (2021). Difference-in-differences with multiple time periods. Journal of econometrics, 225(2), 200-230.

- Cohen, J., Cohen, P., West, S. G., & Aiken, L. S. (2013). Applied multiple regression/correlation analysis for the behavioral sciences. Routledge.; Abrufbar unter: https://doi.org/10.4324/9780203774441 

- Draca, M., Machin, S., & Van Reenen, J. (2011). Minimum wages and firm profitability. American economic journal: applied economics, 3(1), 129-151.

- Brown, William (2007), Friedrich-Ebert-Stiftung, Büro London, London; abrufbar unter: https://library.fes.de/pdf-files/bueros/london/04855-20071107.pdf

- OECD (2002), OECD Employment Outlook 2002, OECD Publishing, Paris

- https://webarchive.nationalarchives.gov.uk/ukgwa/20160105160709/http://www.ons.gov.uk/ons/guide-method/classifications/archived-standard-classifications/uk-standard-industrial-classification-1992--sic92-/uk-sic-2003.pdf (Letzter Aufruf: 05.02.2025)


**R Pakete und Darstellungen**

- https://dplyr.tidyverse.org/reference/group_by.html (Letzter Aufruf: 05.02.2025)

- https://cran.r-project.org/web/packages/ggdag/vignettes/intro-to-dags.html (Letzter Aufruf: 05.02.2025)

- https://r-causal.github.io/ggdag/ (Letzter Aufruf: 05.02.2025)

- https://markdown-syntax.de/Syntax-GFM/Tabellen/ (Letzter Aufruf: 05.02.2025)

- https://www.rdocumentation.org/packages/stargazer/versions/5.2.3/topics/stargazer (Letzter Aufruf: 05.02.2025)

- https://www.rdocumentation.org/packages/lfe/versions/2.9-0/topics/felm (Letzter Aufruf: 05.02.2025)

- https://cran.r-project.org/web/packages/broom/vignettes/broom.html (Letzter Aufruf: 05.02.2025)



## Exercise Einreichen Ihrer Lösung

Um Ihre Lösung abzugeben, gehen Sie wie folgt vor:

1. Scrollen Sie nach oben und drücken auf das Balkensymbol <i class="fa fa-tasks fa-fw"></i> um zu sehen, wie viele Punkte Sie bisher erreicht haben. Um eine höhere Punktzahl zu erlangen, können Sie sich an den noch ungelösten Aufgaben versuchen.

2. Wenn Sie Ihre Lösung abgeben wollen, drücken Sie auf den Download <i class="fa  fa-download fa-fw"></i> ganz rechts.

3. Im geöffneten Tab wählen Sie die Schaltfläche "Download Submission File". Ihr Browser sollte daraufhin eine Datei mit der Endung `.sub` herunterladen.

4. Laden Sie Ihre heruntergeladene Datei auf einer entsprechenden Lernplattform wie Moodle hoch, genaue Anweisungen erhalten Sie von Ihrem Dozenten.



